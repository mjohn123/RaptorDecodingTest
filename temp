#include <iostream>
#include <stdio.h>
#include <vector>
#include <stdlib.h>
#include <string.h>
#include <queue>
#define random(x) (rand()%x)
typedef unsigned char  U8,  *PU8;
typedef unsigned int   U32, *PU32;
using std::vector;
using std::queue;

class CData
{
private:
  U8* m_Data;
  U32  m_Len;
public:
  U8 *GetData(void) const { return m_Data; }
  U32 GetLen(void) const { return m_Len; }
  CData(void): m_Data(NULL), m_Len(0)
  { 
  }
  ~CData(void)
  {    
  }
  CData(U8* data, U32 len): m_Data(NULL), m_Len(0) {SetData(data, len);};  
  void FreeData()
  {
    if (m_Data)
    {
      delete[] m_Data;
      m_Data = NULL;
    }
  }
  void SetData(const U8* data, U32 len)
  {
    FreeData();
    if (len > 0 && data)
    {
      m_Data = new U8[len];
      memcpy(m_Data, data, len);
      m_Len = len;
    }
  }


  void XorData(CData* data)
  {
    return XorData(data->GetData(), data->GetLen());
  }

  void XorData(const U8* data, U32 len)
  {

    if (len > m_Len)
    {
      U8* tmp = new U8[len];
      memset(tmp,0,len);
      if (m_Len > 0)
      {
	memcpy(tmp, m_Data, m_Len);
      }
      FreeData();
      m_Data = tmp;
      m_Len = len;
    }
    
    for (U32 i = 0; i < m_Len; ++i)
    {
      m_Data[i] ^= data[i];
    }
  }
};

queue<CData*>  setData()
{
  printf("\nInput is generated by random:\n");
  U32 index = 0;
  int k=8;
  U32 dataLen=1;
  U8 *buf = new U8[dataLen];
  queue<CData*> res;
  for (U32 i = 0; i < k; ++i)
  {
    vector<U8> rndData;
    rndData.reserve(dataLen);
    for (U32 j = 0; j < dataLen; ++j)
    {
      rndData.push_back(random(256));
      index++;
      printf("%6d", rndData[j]);
      buf[j] = rndData[j];
    }
    //CData data(buf, dataLen);
    //res.push(&data);
    res.push(new CData(buf, dataLen));
  }
  printf("\n");
  delete [] buf;
  buf = NULL;
  return res;
}

void getData(queue<CData*> res_in)
{
  printf("\nGet input data:\n");
  vector<U8> out_data;
  U8 *buf =NULL;
  while (!res_in.empty())
  {    
    CData* data = res_in.front();    
    buf =data->GetData();
    int data_size = data->GetLen();
    for (int j = 0; j < data_size; ++j)
    {    
      out_data.push_back(buf[j]);
    }
    res_in.pop();
  }
  //Print output data
  for (int j = 0; j < out_data.size(); ++j)
  {    
    printf("%6d ",out_data[j]);
  }
  delete [] buf;
  buf = NULL;
}


void set_data_vec(const std::vector<unsigned char> &vecData)
{
  //Set no point can do as above. For pointer need this code
  size_t data_size = vecData.size();
  U8 *data_buf = new U8[data_size];
  for (size_t i = 0; i < data_size; ++i)
  {
    data_buf[i] = vecData[i];

  }
  addData(new CData(data_buf, data_size));
  delete[] data_buf;
  data_buf = NULL;
}
void addData(queue<CData*> source)
{
  if(m_CountLA<=m_K0)
    m_SourceLA[m_CountLA + m_SH0].XorData(source);
  if(m_K0<m_CountLA)
    m_SourceLA[m_L0 + m_SH1].XorData(source);
  m_CountLA++;  

  printf("\nSource add in encoding\n");
  for (U32 i = 0; i < m_LA; ++i)
    {
      U32 length = m_SourceLA[i].GetLen();
      for (U32 j = 0; j < length; ++j)
      {
        printf("%6d", m_SourceLA[i].GetData()[j]);

      }     
    }

}
CData   *m_SourceLA;  
U8 m_LA=28;
U8 m_CountLA=0;
U8 m_K0=4;
U8 m_K1=4;
U8 m_SH0=10;
U8 m_SH1=10;
U8 m_L0=m_SH0+m_K0;
U8 dataLen=1;
int main(int argc, char **argv) {
  

  m_SourceLA = new CData[m_LA];
  memset(m_SourceLA, 0, m_LA * sizeof(CData));  
  for (U32 i = 0; i < m_K0; ++i)
  {
    vector<U8> rndData;
    rndData.reserve(dataLen);
    for (U32 j = 0; j < dataLen; ++j)
    {
      rndData.push_back(random(256));
      //rndData.push_back(original_data[i]);
      printf("%6d", rndData[j]);  

    }
    set_data_vec(rndData);
  }
  printf("\nSource Enhancement Layer\n");
  for (U32 i = 0; i < m_K1; ++i)
  {
    vector<U8> rndData;
    rndData.reserve(dataLen);
    for (U32 j = 0; j < dataLen; ++j)
    {
      rndData.push_back(random(256));
      //rndData.push_back(original_data[i]);
      printf("%6d", rndData[j]);  

    }
    set_data_vec(rndData);
  }
  
  
  
  
    queue<CData*> res_in=setData();
    getData(res_in);
    return 0;
}